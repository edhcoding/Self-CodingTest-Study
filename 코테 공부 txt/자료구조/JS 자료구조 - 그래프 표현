컴퓨터가 그래프를 어떻게 표현하는지 부터 알 필요가 있습니다.

특히 그래프의 경우 A노드에서 B노드로 이동하는 등 노드와 노드 사이를 연결하는 간선에 대한 정보까지 포함되는 경우가 많기 때문에 그래프의 다양한 표현 방법에 대해서 정확히 이해하고 현재 해결하고자하는 알고리즘 문제에 대해서 어떤 그래프 표현 방식을 사용해야 하는지 접근 방법에 대해 이해하는 시간을 가져보겠습니다.

그래프를 표현하기 위해서 별도의 자료 구조를 공부하기 보다는 지금까지 공부했던 동적 배열 즉, 자바스크립트에서 기본적으로 제공되는 배열을 어떻게 이용해야 그래프를 효율적으로 표현할 수 있는지에 대해서 초점을 맞춰보겠습니다.

그래프(Graph)란?
- 사물을 정점(vertex, 노드라고도 표현함)과 간선(edge, 도로 즉 A와 B가 연결되어있는 도로, 통로와 같은 표현으로도 표현함)으로 나타내기 위한 도구입니다.

ex) 네비게이션을 구현할 때 하나의 그래프를 이용한다면 도시 or 지점은 정점으로 표현될 수 있고 그러한 정점과 정점을 이어주는 통로와 같은 경우에는 간선으로 표현합니다.

- 그래프는 두 가지 방식으로 구현할 수 있습니다.
1. 인접 행렬(adjacency matrix) : 2차원 배열을 사용하는 방식
2. 인접 리스트(adjacency list) : 연결 리스트를 이용하는 방식

인정 행렬과 인접 리스트는 사용했을때 효율적인 상황에 따라 나눠지게 됩니다.
일반적인 그래프 - 인접 리스트 방식을 사용하면 보다 효율적인 경우가 많습니다. (현실 세계에서는 최단 경로를 구현하는 등 더 쓰임새가 많음)
코딩 테스트나 알고리즘 문제 해결할 때 - 인접 행령 방식 종종 사용되곤 함

인접 행렬(Adjacency Matrix)
- 인접 행렬에서는 그래프를 2차원 배열로 표현합니다.

행과 열 모두 노드의 개수를 나타냅니다.
지금 노드의 개수는 총 3개이고 즉, 정점(vertax)은 3개입니다. 이런 경우에는 3 X 3짜리 2차원 행렬로 표현하는 것을 확인할 수 있습니다.

오른쪽에 보이는 2차원 배열은 간선(edge)에 대한 정보를 담고 있습니다.
0번 노드로 가는 비용은 0이라고 표현되어 있습니다.
0에서 1번 노드로 가는 비용은 3이라고 간선의 비용이 나와있습니다. (가로 행)
0번 노드에서 2번 노드로 가는 비용은 7의 간선 비용이 나옵니다. (가로 행)

반대로
1번 노드에서 0번 노드로 가는 비용은 3의 간선 비용이 (세로 열)
1번에서 1번으로 가는건 0의 간선비용이
1번에서 2번노드로 가는 비용은 존재하지 않기 때문에 무한으로 명시돼 있습니다.

이런식으로 각각의 노드가 다른 노드로 가기위해 명시하는 것이 인접 배열 형태입니다.
일반적으로 행이 시작노드로 표현되고 열이 도착 노드로 표현되는 경우가 많습니다. 그래서 특정 시작노드에서 도착 노드로 가기위한 비용을 명시하는 형태로 사용할 수 있습니다.
노드의 개수 X 노드의 개수만큼의 배열의 크기가 필요합니다.

인접 행렬 - 무방향 무가중치 그래프 (방향 x, 가중치 x)
- 모든 간선이 방향성을 가지지 않는 그래프를 무방향 그래프라고 합니다.
- 모든 간선에 가중치가 없는 그래프를 무가중치 그래프라고 합니다. (즉, 비용이 없고 연결되어있다 안되어있다만 기록되어 있는 그래프)
- 무방향 비가중치 그래프가 주어졋을 때 연결되어 있는 상황을 인접 행렬로 출력할 수 있습니다.

첫번재 줄에서 
0 에서 0 은 0
0노드에서 1로 갈 수 있으니까 1
0 => 1 가능 1
0 => 3 불가능 0

인접 행렬 - 방향 가중치 그래프 (방향 o, 가중치 o)
- 모든 간선이 방향을 가지는 그래프를 방향 그래프라고 합니다.
- 모든 간선에 가중치가 있는 그래프를 가중치 그래프라고 합니다.
- 방향 가중치 그래프가 주어졌을 때 연결되어 있는 상황을 인접 행렬로 출력할 수 있습니다.

0에서 갈 수 있는 노드는 2뿐이고 그때는 가중치 비용은 7 그래서 0 0 7 0
1 과 2는 둘다 갈 수 있으니까 각각 8

인접 리스트(Adjacency List)
- 인접 리스트에서는 그래프를 리스트로 표현합니다.
- 이 표현방식은 자바에서의 동적 배열로도 구현가능합니다.
- 각각 노드마다 자기와 연결되고 있는 노드를 리스트의 원소형태로 표현 할 수 있습니다.

0 에서 0 못가니까 포함 x
0 에서 1로 갈 수 있고 비용 3 (1, 3)
0 에서 2로 갈 수 있고 비용 7 (2, 7)
즉 포함이 안되는 경우도 있어 N X N의 크기의 배열이 필요가 없어 메모리 효율이 더 좋은모습을 볼 수 있습니다.

인접 리스트 - 무방향 무가중치 그래프
- 모든 간선이 방향성을 가지지 않는 그래프를 무방향 그래프라고 합니다.
- 모든 간선에 가중치가 없는 그래프를 무가중치 그래프라고 합니다.
- 무방향 비가중치 그래프가 주어졌을 때 연결되어 있는 상황을 인접 리스트로 출력할 수 있습니다.

인덱스와 매칭 됩니다.
0은 1과 2로 갈 수 있고 비용은 없는 무가중치 이므로 [1, 2]
1번 노드는 0, 2노드로 갈 수 있어서 [0, 2]

인접 리스트 - 방향 가중치 그래프
- 모든 간선이 방향을 가지는 그래프를 방향 그래프라고 합니다.
- 모든 간선에 가중치가 있는 그래프를 가중치 그래프라고 합니다.
- 방향 가중치 그래프가 주어졌을 때 연결되어 있는 상황을 인접 리스트로 출력할 수 있습니다.

0번 노드에서 2번 노드로 갈 수 있고 비용은 7 [(2, 7)]로 표현가능

그래프의 시간 복잡도
1. 인접 행렬 : 모든 정점들의 연결 여부를 저장해 O(V^2)의 공간을 요구합니다.
- 공간 효율성이 떨어지지만, 두 노드의 연결 여부를 O(1)에 확인할 수 있습니다.

2. 인접 리스트 : 연결된 간선의 정보만을 저장하여 O(V + E)의 공간을 요구합니다.
- 공간 효율성이 우수하지만, 두 노드의 연결 여부를 확인하기 위해 O(V)의 시간이 필요합니다. - 특정 노드에 대해서 연결된 모든 간선을 하나씩 확인해야하기 때문

그렇다면 어떤 방식이 더 좋을까?
- 최단 경로 알고리즘을 구현한다면 어떤 자료구조가 더 좋을까?
- 각각 근처의 노드와 연결되어 있는 경우가 많으므로, 간선 개수가 적다는 측면에서 인접 리스트가 유리합니다.
