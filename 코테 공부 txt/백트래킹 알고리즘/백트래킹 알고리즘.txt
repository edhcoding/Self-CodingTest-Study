코딩 테스트 공부하면서 기록하기위한 게시글입니다.

백트래킹 알고리즘은 코딩 테스트에서 자주 출제되는 알고리즘이기 때문에 잘 이해해둬야 합니다.

백트래킹을 이용하면 특정 그래프가 주어졌을 때 완전 탐색을 수행할 수 있습니다.

일반적으로 모든 경우의 수를 고려해야 할 때 일반적으로 첫 번째로 사용해 볼 수 있는 접근 방법 중 하나 입니다.

그럼 백트래킹에 대해서 자세하게 공부해보겠습니다.

백트래킹이란?

- 일반적으로 그래프/트리의 모든 원소를 완전 탐색하기 위한 목적으로 사용할 수 있습니다.

- 추후에 공부할 DFS와의 차이점은 아래와 같습니다.

1) DFS는 일반적으로 완전 탐색 목적으로, 재귀 함수를 이용해 구현합니다.

2) 백트래킹도 재귀 함수를 이용해 구현하는 것이 일반적이지만, 단순히 완전 탐색하는 것이 아니라 조건에 따라서 유망한 노드로 이동합니다.

백트래킹을 DFS보다 먼저 다루는 이유

- 실질적으로 백트래킹이 DFS보다 코딩 테스트에서 출제 빈도가 높고

- DFS를 이용해서 백트래킹을 구현하는 경우가 굉장히 많이 요구되기 때문에

- 백트래킹의 사용 예시 및 코드를 우선적으로 먼저 알아본 뒤에 그 다음 백트래킹의 더 일반화된 형태라고 할 수 있는 DFS에 대해서 추후에 알아보는 방식이 좋습니다.

그래프 표현 방식 (https://edongdong.tistory.com/266)

첫 번째 노드 or 정점으로 표현된 그래프를 표현하는 두 가지 방식이 있습니다.

1. 인접 행렬(adjacency matrix) : 2차원 배열을 사용하는 방식

2. 인접 리스트(adjacency list) : 연결 리스트를 이용하는 방식

인접 리스트 방식은 간선의 개수가 적을때 효율적입니다!

N-Queen 문제 (백트래킹의 전형적인 문제)

- 완전 탐색 유형 중 하나로 백트래킹을 이용해서 해결할 수 있는 문제입니다.

- N X N 체스 보드 위에 퀸 N개가 서로 공격할 수 없게 놓는 문제입니다.

- 예를 들어 8 X 8에 하나의 퀸이 놓여져 있는 예시입니다.

- 하얀색 공간에만 퀸 놓을 수 있습니다.

8 X 8에 8개의 퀸을 서로 공격할 수 없게 놓는 예시는 다음과 같습니다.

이러한 예시가 총 몇개 존재하는지를 완전 탐색을 통해서 계수를 구하는 문제가 N-Queen 문제입니다.

예를들어  N을 8이라고 가정해봅니다.

64개의 위치에 8개의 퀸을 설치하는 모든 조합의 수는 Combination(64, 8) 입니다.

따라서 단순히 모든 경우의 수를 전부 고려한다면?

- 각 퀸이 서로 공격이 가능한지 검사하는 방식을 사용한다면 경우의 수가 매우 커질 수 있습니다.

[문제 해결 아이디어]

완전 탐색을 하더라도 유망한 경우에 대해서만 탐색을 진행한다면?

- 백트래킹 방식을 사용하여 훨씬 경우의 수를 줄일 수 있습니다.

N개의 퀸을 놓기 위해서는 각 행마다 1개의 퀸을 놓아야 합니다.

그러면 1행부터 하나씩 퀸을 놓는다고 생각해봅시다.

첫번째 행에 놓을 수 있는 개수 8 = 2^3개

둘째 행에 놓을 수 있는 개수 8 = 2^3개

...

...

직관적으로 고려하면, 2^24개 경우가 있습니다.

하나의 퀸 A가 이미 존재하는 상태에서, 다른 퀸 B를 놓으려면 어떻게 하면 될까?

- 퀸 A의 상하좌우 및 대각선 위치가 아닌 위치에 퀸 B를 놓을 수 있습니다.

그래서 이걸 트리구조 or 그래프 구조로 표현하면 이해가 쉽습니다. (참고로 트리는 그래프의 일종)

하나의 퀸 A가 이미 존재한다면, 다른 퀸 B는 어떻게 해야할까?

- 아래와 같이 가능한 경우만 파고들어가서 고려하는 방식으로 백트래킹이 동작하는 것을 확인할 수 있습니다.

백트래킹을 진행할 때, 경우의 수를 최대한 줄이는 방법은?

- 방법 : 이전까지 놓았던 퀸들과 상충되지 않는 조건을 만족하는 위치에 대해서만 재귀 함수를 호출

1) 재귀 함수를 통해 코든 경우의 수를 다 찾은 뒤에, 각 경우마다 가능한지 검사하는 방법

2) 유망한 경우에 대해서만 재귀 함수를 호출하는 방법

위 경우에서는 2) 방법이 더 효율적입니다.

백트래킹의 일반적인 코드 형태

- 재귀함수는 무조건 종료 조건이 존재합니다.(아니면 무한루프의 맛을 볼 수 있..)

루트노드에서 자식노드로 내려갑니다.

결국 마지막으로 앞선 공부를 통해

N-Queen 문제 해결 아이디어

- 이 문제는 가능한 모든 조합의 수를 구하는 것과 같습니다.

- 매 재귀함수마다 실제로 N X N 모든 위치를 모두 볼 필요가 없습니다.

[핵심] 맨 처음 행(row)부터 차례대로 퀸을 놓는다고 생가갛면 가짓수를 훨씬 줄일 수 있습니다.

- N-Queen 문제는 가능한 조합을 계산하는 것이므로, 현재 행의 이전 행으로 돌아갈 필요가 없습니다.

백트래킹은 기본적으로 가능한 노드에 대하여 계속해서 재귀적으로 함수를 호출합니다.

백트래킹은 모든 경우의 수를 탐색하기에 적합합니다.

N-Queen 문제를 해결하기 위해서는 특정 위치(노드)의 가능 여부를 판단할 필요가 있습니다.

가능한 노드 여부는 다음의 두 가지를 보면 됩니다.

1) 같은 행에 있는지 체크 : x1 == x2 / 같은 열에 있는지 체크 : y1 == y2

2) 대각선에 있는지 체크 : abs(x1, x2) == abs(y1, y2)

N-Queen 정답 코드 예시

- 변수 queens는 2차월 배열 형태로 사용

- possible 함수는 x,y 위치에 놓을 수 있는지 검사 (조건에 따라서 완전 탐색 수행)

- dfs 함수를 수행하면 0번 인덱스, 첫 번째 행부터 차례대로 놓게됩니다.

- 그래서 row가 n이라면 n개의 퀸을 모두 배치한거기 때문에 카운트 해주고 그렇지 않다면 자식노드를 하나씩 확인하는겁니다.

- 그래서 현재 행에 존재하는 모든 열들의 각 위치를 하나씩 확인하면서 놓을 수 있다면 놓고 아니라면 무시할 수 있도록 continue 사용

- 놓도록하고 재귀함수를 호출한뒤에 다시 그 위치에 퀸을 꺼내도록 pop을 수행해서 스택에서 꺼내주는 방식으로 구현할 수 있습니다.

let n = 8; // 전체 맵(map)의 크기
let queens = []; // 현재 체스판에 놓인 퀸(queen)의 위치 정보들

function possible(x, y) { // (x, y) 위치에 퀸을 놓을 수 있는지 확인
    for (let [a, b] of queens) { // 현재까지 놓았던 모든 퀸(queen)의 위치를 하나씩 확인하며
        if (a == x || b == y) return false; // 행이나 열이 같다면 놓을 수 없음
        if (Math.abs(a - x) == Math.abs(b - y)) return false; // 대각선에 위치한 경우 놓을 수 없음
    }
    return true;
}

let cnt = 0;
function dfs(row) {
    if (row == n) cnt += 1; // 퀸(queen)을 N개 배치할 수 있는 경우 카운트
    for (let i = 0; i < n; i++) { // 현재 행(row)에 존재하는 열을 하나씩 확인하며
        if (!possible(row, i)) continue; // 현재 위치에 놓을 수 없다면 무시
        queens.push([row, i]); // 현재 위치에 퀸을 놓기
        dfs(row + 1); // 재귀 함수 호출
        queens.pop(); // 현재 위치에서 퀸을 제거하기
    }
}

dfs(0);
console.log(cnt);